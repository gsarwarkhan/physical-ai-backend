---
id: chapter-2-nodes-topics-services
title: 'Chapter 2: Nodes, Topics, and Services'
sidebar_label: 'Chapter 2: Core Concepts'
---

# Chapter 2: Nodes, Topics, and Services: The Building Blocks of ROS 2

In the previous chapter, we introduced the high-level architecture of ROS 2. Now, we delve into the fundamental concepts that enable communication and data flow within a robotic system: **Nodes**, **Topics**, and **Services**. Understanding these building blocks is crucial for developing robust and modular robotics applications, especially in the context of humanoid robots.

## The Core Concepts

### Nodes: The Computational Units

A **Node** is the primary computational unit in a ROS 2 system. Think of a node as a small, independent program that performs a specific task. For example, a humanoid robot might have separate nodes for:

-   Controlling the motors in the left leg (`left_leg_controller`)
-   Processing data from a camera (`camera_driver`)
-   Planning a path to a destination (`path_planner`)
-   Aggregating sensor data to understand the environment (`perception_system`)

:::info Modularity and Resilience
Each node is a self-contained executable that can be run, stopped, and restarted independently. This modularity is a cornerstone of ROS 2's design, allowing for complex systems to be built from smaller, reusable components. If one node crashes, it ideally does not bring down the entire robot system.
:::

### Topics: The Asynchronous Data Streams for Sensor Data

**Topics** are named buses over which nodes exchange messages. They are the primary mechanism for asynchronous, one-to-many communication. A node can **publish** messages to a topic, and any number of other nodes can **subscribe** to that topic to receive those messages.

-   **Publish/Subscribe (Pub/Sub) Model**: This model decouples data producers from data consumers. A node publishing camera images doesn't need to know which other nodes are using those images. It simply sends the data to the `/camera/image_raw` topic.
-   **Message Types**: Every topic has a specific message type, which defines the data structure of the messages being sent. For example, a camera topic might use `sensor_msgs/msg/Image`, while a motor command topic might use `std_msgs/msg/Float64`.

:::tip Humanoid Robot and Topics
A humanoid robot extensively uses topics for continuous sensor data. For instance:
-   **Vision**: `/camera/image_raw`, `/camera/depth_image`, `/camera/points` (from an RGB-D camera)
-   **Proprioception**: `/joint_states` (reporting current joint angles and velocities)
-   **Force/Torque**: `/feet/force_sensors`, `/hands/force_sensors`
-   **Auditory**: `/microphone/audio_raw`

These continuous streams of data allow the robot's perception and control nodes to stay updated with its internal state and external environment.
:::

### Services: The Synchronous Request/Response for Specific Tasks

**Services** provide a mechanism for synchronous, one-to-one communication. Unlike topics, services operate on a request/response model, similar to a remote procedure call (RPC).

-   **Client/Server Model**: A **Service Server** node offers a specific service and waits for requests. A **Service Client** node sends a request and waits for a response from the server.
-   **Service Types**: Like topics, services have a defined type, which consists of two parts: a request message and a response message.

:::tip Humanoid Robot and Services
Services are ideal for specific, one-shot actions or queries. For a humanoid robot, this might include:
-   **Grasping an Object**: A client node (e.g., a task planner) might call a `/hand_controller/grasp_object` service, providing the object's coordinates. The server node (the hand controller) would execute the grasp and return a success/failure response.
-   **Changing Gait**: A `/locomotion_controller/set_gait` service might be called to switch from walking to running.
-   **System Query**: A `/diagnostics/get_status` service could be used to query the health status of a particular subsystem.
:::

## Python Code Example: Publisher and Subscriber

Let's illustrate the publish/subscribe mechanism with a simple Python example. We'll create two nodes: a `Talker` that publishes "hello" messages and a `Listener` that subscribes to and prints them.

### `talker_node.py` (Publisher)

```python title="talker_node.py"
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Talker(Node):
    """
    A simple publisher node that sends 'hello world' messages.
    """
    def __init__(self):
        super().__init__('talker')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
        self.get_logger().info('Talker node has been started.')

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    talker_node = Talker()
    rclpy.spin(talker_node)
    talker_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### `listener_node.py` (Subscriber)

```python title="listener_node.py"
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class Listener(Node):
    """
    A simple subscriber node that receives and prints messages from the 'chatter' topic.
    """
    def __init__(self):
        super().__init__('listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10
        )
        self.get_logger().info('Listener node has been started, subscribing to "chatter".')
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    listener_node = Listener()
    rclpy.spin(listener_node)
    listener_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run this example:
1.  Save the code snippets as `talker_node.py` and `listener_node.py` in your ROS 2 workspace (e.g., within a package's `scripts` directory).
2.  Open two separate terminals.
3.  In the first terminal, source your ROS 2 environment and run the talker:
    `python3 talker_node.py`
4.  In the second terminal, source your ROS 2 environment and run the listener:
    `python3 listener_node.py`

You will see the talker publishing messages and the listener receiving and printing them, demonstrating the fundamental ROS 2 communication pattern.

:::warning Real-Time Guarantees and Latency in Physical AI

In physical AI systems, especially humanoid robotics, latency is not just a performance metricâ€”it's a critical safety and stability factor. The time it takes for a sensor signal to be processed and result in a motor command can be the difference between a stable gait and a fall.

While ROS 2 is highly performant, it is **not a hard real-time system** by default. Communication over topics, even with QoS (Quality of Service) settings, is subject to network and operating system scheduling latencies. For true real-time control loops (e.g., maintaining balance), developers often rely on specialized real-time operating systems (RTOS) or dedicated microcontrollers that interface with the main ROS 2 system.

Always assume non-deterministic latency in standard ROS 2 communication and design your critical control systems accordingly.

:::

This example illustrates the power of ROS 2's architecture. The modular approach with Nodes, Topics, and Services provides a robust framework for building complex robotic behaviors. In the following chapters, we will explore these concepts in greater depth, learning how to create custom messages and services, and how to use more advanced features of the ROS 2 ecosystem.